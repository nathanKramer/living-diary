# Living Diary

An AI-powered memory companion that lives in Telegram. It remembers conversations, extracts key facts and diary entries, and recalls them naturally using vector search.

## Tech stack

- **TypeScript** (ESM, strict mode) with **pnpm**
- **grammY** — Telegram bot framework (polling mode)
- **Vercel AI SDK v6** (`ai` package) — multi-provider LLM access
- **@ai-sdk/anthropic** — Claude for conversation and extraction
- **@ai-sdk/openai** — OpenAI embeddings only (text-embedding-3-small, 1536 dims)
- **LanceDB** — embedded vector database (no server, file-backed in `data/`)
- **Apache Arrow** — schema definition for LanceDB tables
- **zod v4** — tool parameter schemas for AI SDK tool calling

## Architecture

```
src/
  index.ts              # Entry point — inits memory, starts Express, creates bot
  config.ts             # Env var loading with validation
  shared/types.ts       # Shared types (Memory, MemoryType, Person, Relationship, PeopleGraph) used by backend and web
  bot/index.ts          # grammY bot — allowlist gate, approval callbacks, commands, message handler
  allowlist/index.ts    # AllowlistHolder — persistent approved users + pending requests
  ai/
    index.ts            # generateDiaryResponse() — tool-calling LLM with 6 memory tools
    system-prompt.ts    # Base prompt + persona layering, injects today's date
    extract.ts          # Background memory extraction from user messages
    configure.ts        # /configure — generates persona from user description
    describe-photo.ts   # Claude vision — describes photos for memory storage
  memory/index.ts       # MemoryStore class — LanceDB CRUD with vector dedup
  persona/index.ts      # Load/save/delete persona + PersonaHolder shared state
  people/index.ts       # PeopleGraphHolder — JSON-backed people & relationships graph
  server/
    index.ts            # Express app — serves dashboard API and static files
    routes/memories.ts  # REST API for memory browsing
    routes/persona.ts   # REST API for persona CRUD (generate, edit, reset)
    routes/people.ts    # REST API for people graph CRUD
    middleware/auth.ts   # Bearer token auth for dashboard
web/                    # React dashboard (Vite, separate package.json)
  src/
    App.tsx             # Tab-based root (All / Search / People / Stats / Settings)
    api.ts              # Fetch wrapper with auth token
    components/         # AuthGate, Layout, MemoryList, MemoryCard, SearchBar, StatsPanel, PersonaPanel, PeoplePanel
```

## Key design decisions

**Tool calling over hardcoded queries**: The AI has 6 tools (`search_memories`, `search_by_date`, `get_user_facts`, `get_recent_memories`, `send_photo`, `get_person_info`) and decides which to call based on the conversation. Uses `stopWhen: stepCountIs(5)` for multi-step tool loops.

**AI SDK v6 specifics**: Tools use `inputSchema` (not `parameters`). Multi-step uses `stopWhen: stepCountIs(n)` (not `maxSteps`). The `tool()` helper is from `ai` package.

**Memory deduplication**: `addMemory()` checks cosine distance against existing memories before inserting. User facts threshold: 0.10 (aggressive). Diary entries: 0.05 (tighter). Returns `null` if duplicate.

**Multi-user**: Memories have a `userId` field. User facts are filtered to the current speaker. Diary entries are shared across all users (enables family context).

**Admin-approval pairing**: New DM users trigger an approval request to the admin (configured via `ADMIN_TELEGRAM_ID`). The admin gets inline buttons to approve or reject. Approved user IDs are persisted to `data/allowlist.json`. The admin is always pre-approved. `ALLOWED_USER_IDS` (optional) seeds the allowlist on first startup for backwards compatibility. `AllowlistHolder` follows the same in-memory holder pattern as `PersonaHolder` and `PeopleGraphHolder`.

**Configurable persona**: System prompt = base behavior + persona. Default is "personal diary companion". Users can `/configure` in Telegram or use the Settings tab in the dashboard to change it (e.g. family diary, company KB). Persona is generated by Claude and saved to `data/persona.json`. A `PersonaHolder` class provides shared mutable state between the bot and server so persona changes from either side are immediately visible.

**Extraction pipeline**: Runs in background after each reply. Only feeds user messages (not AI responses) to avoid re-storing recalled memories. Extraction prompt instructs to only extract NEW information. Also extracts `people_updates` to build the people graph (names, aliases, bios, relationships).

**Safety guardrails**: Two layers prevent storage of sensitive data (passwords, API keys, tokens, credit card numbers, etc.). The system prompt instructs the bot to warn users that memories are not a safe place for secrets. The extraction prompt has a hard rule to never extract credentials or sensitive information.

**People graph**: A JSON file at `data/people.json` stores structured people and relationship data. `PeopleGraphHolder` provides shared mutable state (like `PersonaHolder`). The extraction pipeline populates it automatically when users mention people. Relationships are bidirectional at query time. Pets are modeled as `Person` entries with a `pet` relationship type. `user_fact` memories in LanceDB are kept as-is for vector search — the people graph adds structured lookup on top.

**Web dashboard**: Express runs in the same process as the bot, sharing the MemoryStore, PersonaHolder, and PeopleGraphHolder instances. React app in `web/` with its own Vite build. Types shared via `src/shared/types.ts` and a Vite alias `@shared`. Auth via optional `DASHBOARD_TOKEN` env var. Tabs: All (paginated memory list), Search (semantic vector search), People (people graph management), Stats, Settings (persona management).

## Commands

`pnpm dev` — run bot + Express API with tsx watch
`pnpm dev:web` — run Vite dev server for React dashboard (proxy to :3000)
`pnpm build` — compile backend TypeScript + build React app
`pnpm start` — run compiled JS (serves both bot and dashboard)

## Environment variables

See `.env.example`. Required: `TELEGRAM_BOT_TOKEN`, `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, `ADMIN_TELEGRAM_ID`. Optional: `ALLOWED_USER_IDS` (seeds initial allowlist).

## LanceDB schema

Table `memories`: `id` (string), `userId` (float64), `content` (string), `type` (string), `tags` (string, comma-separated), `timestamp` (float64), `photoFileId` (string, nullable), `source` (string, nullable), `subjectName` (string, nullable), `vector` (float32[1536]).

Memory types: `diary_entry`, `user_fact`, `conversation_summary`, `reflection`, `photo_memory`.

Schema migration: `init()` checks for missing columns and recreates the table if needed (drops data — fine for dev).

**LanceDB query limitations**: LanceDB has no native `orderBy` on its query builder. `getRecentMemories()` fetches all rows (excluding the vector column), sorts in JS, and slices — correct for the expected dataset size.

## People graph schema

File `data/people.json` contains a `PeopleGraph` with `people` and `relationships` arrays.

`Person`: `id` (UUID), `name`, `aliases` (string[]), `telegramUserId` (number | null), `bio`, `createdAt`, `updatedAt`.

`Relationship`: `id` (UUID), `personId1`, `personId2`, `type` (sibling | parent | child | partner | friend | coworker | pet | other), `label`, `createdAt`. Bidirectionality handled at query time — search both sides.

API routes: `GET /api/people`, `PUT /api/people/:id`, `POST /api/people/:id/merge`, `DELETE /api/people/:id`, `POST /api/people/relationships`, `DELETE /api/people/relationships/:id`.

## Remaining backlog

See `PLAN.md` for full details. Unimplemented:
- Proactive check-ins and reflections (node-cron scheduler)
- Deployment setup (Docker, process management)
- Tests and documentation
