# Living Diary

An AI-powered memory companion that lives in Telegram. It remembers conversations, extracts key facts and diary entries, and recalls them naturally using vector search.

## Tech stack

- **TypeScript** (ESM, strict mode) with **pnpm**
- **grammY** — Telegram bot framework (polling mode)
- **Vercel AI SDK v6** (`ai` package) — multi-provider LLM access
- **@ai-sdk/anthropic** — Claude for conversation and extraction
- **@ai-sdk/openai** — OpenAI embeddings only (text-embedding-3-small, 1536 dims)
- **LanceDB** — embedded vector database (no server, file-backed in `data/`)
- **Apache Arrow** — schema definition for LanceDB tables
- **zod v4** — tool parameter schemas for AI SDK tool calling

## Architecture

```
src/
  index.ts              # Entry point — inits memory, starts Express, creates bot
  config.ts             # Env var loading with validation
  shared/types.ts       # Shared types (Memory, MemoryType, Person, Relationship, PeopleGraph) used by backend and web
  bot/index.ts          # grammY bot — allowlist gate, approval callbacks, commands, message handler
  allowlist/index.ts    # AllowlistHolder — persistent approved users + pending requests
  core-memories/index.ts # CoreMemoryHolder — bot's self-knowledge (name, identity facts)
  chat-logs/index.ts    # appendLog() + readRecentLogs() — JSONL chat persistence per user
  ai/
    index.ts            # generateDiaryResponse() — tool-calling LLM with 6 memory tools
    system-prompt.ts    # Base prompt + core memories + persona layering, injects today's date
    extract.ts          # Background memory extraction from user messages
    configure.ts        # /configure — generates persona from user description
    describe-photo.ts   # Claude vision — describes photos; LLM people identification for media captions
  memory/index.ts       # MemoryStore class — LanceDB CRUD with vector dedup and update
  persona/index.ts      # Load/save/delete persona + PersonaHolder shared state
  people/index.ts       # PeopleGraphHolder — JSON-backed people & relationships graph
  server/
    index.ts            # Express app — serves dashboard API and static files
    routes/memories.ts  # REST API for memory browsing and editing
    routes/persona.ts   # REST API for persona CRUD (generate, edit, reset)
    routes/people.ts    # REST API for people graph CRUD
    routes/core-memories.ts # REST API for core memories (name, entries)
    routes/chat-logs.ts # REST API for browsing chat logs
    middleware/auth.ts   # Bearer token auth for dashboard
web/                    # React dashboard (Vite, separate package.json)
  src/
    App.tsx             # Tab-based root (All / Search / People / Chats / Stats / Settings)
    api.ts              # Fetch wrapper with auth token
    chat-logs.css       # Chat bubble styles for Chats tab
    components/         # AuthGate, Layout, MemoryList, MemoryCard, SearchBar, StatsPanel, PersonaPanel, PeoplePanel, ChatLogsPanel
```

## Key design decisions

**Tool calling over hardcoded queries**: The AI has 6 tools (`search_memories`, `search_by_date`, `get_user_facts`, `get_recent_memories`, `send_media`, `get_person_info`) and decides which to call based on the conversation. Uses `stopWhen: stepCountIs(5)` for multi-step tool loops.

**AI SDK v6 specifics**: Tools use `inputSchema` (not `parameters`). Multi-step uses `stopWhen: stepCountIs(n)` (not `maxSteps`). The `tool()` helper is from `ai` package.

**Memory deduplication**: `addMemory()` checks cosine distance against existing memories before inserting. User facts threshold: 0.10 (aggressive). Diary entries: 0.05 (tighter). Returns `null` if duplicate.

**Multi-user**: Memories have a `userId` field. User facts are filtered to the current speaker. Diary entries are shared across all users (enables family context).

**Admin-approval pairing**: New DM users trigger an approval request to the admin (configured via `ADMIN_TELEGRAM_ID`). The admin gets inline buttons to approve or reject. Approved user IDs are persisted to `data/allowlist.json`. The admin is always pre-approved. `ALLOWED_USER_IDS` (optional) seeds the allowlist on first startup for backwards compatibility. `AllowlistHolder` follows the same in-memory holder pattern as `PersonaHolder` and `PeopleGraphHolder`.

**Configurable persona**: System prompt = base behavior + persona. Default is "personal diary companion". Users can `/configure` in Telegram or use the Settings tab in the dashboard to change it (e.g. family diary, company KB). Persona is generated by Claude and saved to `data/persona.json`. A `PersonaHolder` class provides shared mutable state between the bot and server so persona changes from either side are immediately visible.

**Core memories**: Bot self-knowledge stored in `data/core-memories.json`. `CoreMemoryHolder` follows the same holder pattern. Has a dedicated `name` field (the diary's chosen name) and a `entries` array (free-form self-knowledge facts, max 20). Injected into the system prompt as an "About you" section between the date and persona. The `/name` Telegram command sets the name directly. Core memories are also extractable from conversation — if a user says "I'll call you Luna", the extraction pipeline detects it and stores the name automatically via `core_updates` in the extraction result. Dashboard Settings tab has a Core Memories section for manual editing.

**Extraction pipeline**: Runs in background after each reply. Only feeds user messages (not AI responses) to avoid re-storing recalled memories. Extraction prompt instructs to only extract NEW information. Also extracts `people_updates` to build the people graph and `core_updates` for bot self-knowledge (name, identity facts).

**Safety guardrails**: Two layers prevent storage of sensitive data (passwords, API keys, tokens, credit card numbers, etc.). The system prompt instructs the bot to warn users that memories are not a safe place for secrets. The extraction prompt has a hard rule to never extract credentials or sensitive information.

**People graph**: A JSON file at `data/people.json` stores structured people and relationship data. `PeopleGraphHolder` provides shared mutable state (like `PersonaHolder`). The extraction pipeline populates it automatically when users mention people. Relationships are bidirectional at query time. Pets are modeled as `Person` entries with a `pet` relationship type. `user_fact` memories in LanceDB are kept as-is for vector search — the people graph adds structured lookup on top.

**Photo and video people tagging**: When a user sends a photo or video with a caption, an LLM call (`identifyPeopleInPhoto` in `describe-photo.ts`) resolves mentions — including indirect references like "me", "mum", nicknames — against the known people graph. The sender's person entry is annotated so "me" resolves correctly. Matched canonical names are stored as a comma-separated `subjectName` on the memory. `getMemoriesBySubject()` fetches all rows with non-null `subjectName` and filters in JS by splitting on commas, so a memory tagged `"Oscar, Nathan"` matches searches for either person.

**Video memories**: Videos are handled like photos but without the vision model call. The caption is stored as the memory content (or a default description if no caption). The Telegram video `file_id` is stored in `photoFileId` (reused to avoid schema changes). The `video_memory` type distinguishes them from photos. `send_media` tool handles both photo and video sending, including mixed media groups via Telegram's `sendMediaGroup`.

**Memory editing**: Memories can be edited inline in the dashboard (content, type, tags, subjectName). `PUT /api/memories/:id` calls `MemoryStore.updateMemory()` which does delete + re-insert (LanceDB has no native row update). If content changes, the vector is re-embedded; otherwise the existing vector is reused (converted from Arrow typed array via `Array.from()`).

**Chat log persistence**: All chat messages (user and assistant) are persisted to JSONL files at `data/chat-logs/{userId}.jsonl`. Each line is `{"role","content","timestamp"}`. `appendLog()` is fire-and-forget (no await). On bot restart, when a user's session is empty, hydration middleware loads the last 20 messages from their log file via `readRecentLogs()`. This preserves conversational context across restarts. Photo/video handlers log the synthetic session text (e.g. `[User sent a photo with caption: "..."]`) and the bot's reply.

**Web dashboard**: Express runs in the same process as the bot, sharing the MemoryStore, PersonaHolder, PeopleGraphHolder, and CoreMemoryHolder instances. React app in `web/` with its own Vite build. Types shared via `src/shared/types.ts` and a Vite alias `@shared`. Auth via optional `DASHBOARD_TOKEN` env var. Tabs: All (paginated memory list), Search (semantic vector search), People (people graph management), Stats, Settings (core memories + persona management).

## Commands

`pnpm dev` — run bot + Express API with tsx watch
`pnpm dev:web` — run Vite dev server for React dashboard (proxy to :3000)
`pnpm build` — compile backend TypeScript + build React app
`pnpm start` — run compiled JS (serves both bot and dashboard)

## Environment variables

See `.env.example`. Required: `TELEGRAM_BOT_TOKEN`, `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, `ADMIN_TELEGRAM_ID`. Optional: `ALLOWED_USER_IDS` (seeds initial allowlist).

## LanceDB schema

Table `memories`: `id` (string), `userId` (float64), `content` (string), `type` (string), `tags` (string, comma-separated), `timestamp` (float64), `photoFileId` (string, nullable), `source` (string, nullable), `subjectName` (string, nullable), `vector` (float32[1536]).

Memory types: `diary_entry`, `user_fact`, `conversation_summary`, `reflection`, `photo_memory`, `video_memory`.

Schema migration: `init()` checks for missing columns and recreates the table if needed (drops data — fine for dev).

**LanceDB query limitations**: LanceDB has no native `orderBy` on its query builder. `getRecentMemories()` fetches all rows (excluding the vector column), sorts in JS, and slices — correct for the expected dataset size. LanceDB also has no native row update, so `updateMemory()` deletes the old row and re-inserts with updated fields.

## People graph schema

File `data/people.json` contains a `PeopleGraph` with `people` and `relationships` arrays.

`Person`: `id` (UUID), `name`, `aliases` (string[]), `telegramUserId` (number | null), `bio`, `createdAt`, `updatedAt`.

`Relationship`: `id` (UUID), `personId1`, `personId2`, `type` (sibling | parent | child | partner | friend | coworker | pet | other), `label`, `createdAt`. Bidirectionality handled at query time — search both sides.

Memory API routes: `GET /api/memories`, `GET /api/memories/search`, `GET /api/memories/by-subject`, `GET /api/memories/date-range`, `GET /api/memories/stats`, `PUT /api/memories/:id`, `DELETE /api/memories/:id`.

People API routes: `GET /api/people`, `PUT /api/people/:id`, `POST /api/people/:id/merge`, `DELETE /api/people/:id`, `POST /api/people/relationships`, `DELETE /api/people/relationships/:id`.

Core memories API routes: `GET /api/core-memories`, `PUT /api/core-memories/name`, `POST /api/core-memories/entries`, `DELETE /api/core-memories/entries/:id`.

Chat logs API routes: `GET /api/chat-logs` (list users with logs), `GET /api/chat-logs/:userId` (get messages, optional `?limit=N`).

## Remaining backlog

See `PLAN.md` for full details. Unimplemented:
- Proactive check-ins and reflections (node-cron scheduler)
- Deployment setup (Docker, process management)
- Tests and documentation
